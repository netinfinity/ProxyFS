This file will track the ongoing API & Internal changes that are, at the time, still needed
===========================================================================================

Specific API changes:

craigster> It looks like the API changes you are describing are for a hypothetical "/.snapshot" directory.
craigster> Many, but not all of these changes apply to all files and directories on the snapshot.

craigster> We need a notion of a Read-only file system.  Snapshots are read-only, but other file systems
craigster> could become read-only (or disabled) as a result of storage updates or otherwise.  As far as
craigster> Access() and other modifying operations are concerned, the correct error is EROFS (Read Only
craigster> FileSystem), and not EPERM (Permissions failure).

edmc> As discussed in channel, EROFS is a problem for us in the "all snapshots & live view in a single
edmc> file system" case. EROFS might confuse the client into thinking the entire file system is, therefore,
edmc> read-only.

edmc> However, when mounting a filesystem's snapshot, it should be marked as read-only in the mount
edmc> options. Unclear to me whether or not package fs (who receives this mount option) enforces that
edmc> setting - it should - so perhaps all we need to do is ensure that option is provided (or, I guess,
edmc> assume that it was) at time of mounting such that EROFS is generated for any modifying operations
edmc> to a mounted snapshot.

Done?  API                        Modifications
-----  -------------------------  ---------------------------------------------------------
	   SnapShotDeleteByFSLayer()  Invalidate all inodeCache entries with that SnapShotID
	   Access()                   Say "no" to W_OK requests
                                  Map /.snapshot access checks to that of /
	   Destroy()                  SnapShot inodes are only destroyed by deleting the SnapShot
	   GetMetadata()              Return appropriate(?) result for /.snapshot
  Y    GetType()                  Return DirType for /.snapshot
	   GetLinkCount()             Return 2 + # of SnapShots for /.snapshot
	                              Return LinkCount+1 for / if there are any SnapShots
  Y    SetLinkCount()             No write access to SnapShots
  Y    SetCreationTime()          No write access to SnapShots
  Y    SetModificationTime()      No write access to SnapShots
  Y    SetAccessTime()            No write access to SnapShots
  Y    SetPermMode()              No write access to SnapShots
  Y    SetOwnerUserID()           No write access to SnapShots
  Y    SetOwnerUserIDGroupID()    No write access to SnapShots
  Y    SetOwnerGroupID()          No write access to SnapShots
  Y    PutStream()                No write access to SnapShots
  Y    DeleteStream()             No write access to SnapShots
  Y    FetchLayoutReport()        Return empty result for /.snapshot
	   Validate()                 Ensure it doesn't attempt to mark SnapShot Inode's dirty
                                  Return success if validating /.snapshot
	   Link()                     Fail if either dirInodeNumber    or targetInodeNumber have a non-zero SnapShot ID
	   Unlink()                   Fail if        dirInodeNumber                         has  a non-zero SnapShot ID
	   Move()                     Fail if either srcDirInodeNumber or dstDirInodeNumber have a non-zero SnapShot ID
	   Lookup()                   Emulate search in /.snapshot pseudo dir
	                              Find .snapshot in / only if there are any SnapShots
                                  Replace .. reference in SnapShot's root dir with reference to /.snapshot
	   NumDirEntries()            Emulate count of /.snapshot pseudo dir
	   ReadDir()                  Emulate readdir of /.snapshot pseudo dir
	                              Return .snapshot in / only if there are any SnapShots
                                  Replace .. reference in SnapShot's root dir with reference to /.snapshot
  Y    Write()                    No write access to SnapShots
  Y    Wrote()                    No write access to SnapShots
  Y    SetSize()                  No write access to SnapShots
	   Coalesce()                 Fail if containingDirInode has a non-zero SnapShot ID
                                  Fail if containingDirInode is / and combinationName is .snapshot
                                  Fail if any elements reference a ContainingDirectoryInodeNumber or ElementInodeNumber with a non-zero SnapShot ID

Changes required in fetchOnDiskInode()/headhunter:

Done?  Modifications
-----  ------------------------------------------------------------------------------------------------------------
       vS.headhunterVolumeHandle.GetInodeRec(uint64(inodeNumber)) call needs to consult appropriate SnapShot
  Y    Research why a fetched inode is initially marked Dirty?
  -      In short, we see no reason for it... so making the change to no longer do it now.
       Need to make it "easy" for SnapShotDeleteByFSLayer() to delete all inodeCache elements with that SnapShot ID

Changes required in inodeCache:

Done?  Modifications
-----  ------------------------------------------------------------------------------------------------------------
       Convert inodeCache from a map[InodeNumber]*inMemoryInodeStruct to a sortedmap.LLRBTree
       At SnapShot deletion time, delete all entries with the specified SnapShotID (nicely - don't hold lock long)
